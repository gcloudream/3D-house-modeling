# QtPlanArchitect 技术难点与解决方案

本文档列举项目开发过程中的主要技术难点、易错点,并提供通俗易懂的解决方案。

---

## 目录

1. [墙体几何计算与渲染](#1-墙体几何计算与渲染)
2. [墙体智能连接算法](#2-墙体智能连接算法)
3. [2D/3D 坐标系转换与同步](#3-2d3d-坐标系转换与同步)
4. [吸附系统的精度与性能](#4-吸附系统的精度与性能)
5. [门窗开洞算法](#5-门窗开洞算法)
6. [OpenGL 渲染性能优化](#6-opengl-渲染性能优化)
7. [撤销/重做系统设计](#7-撤销重做系统设计)
8. [内存管理与资源泄漏](#8-内存管理与资源泄漏)
9. [数据序列化与版本兼容](#9-数据序列化与版本兼容)
10. [用户交互的响应性](#10-用户交互的响应性)

---

## 1. 墙体几何计算与渲染

### 难点描述

**问题**: 墙体在软件中用"中心线"表示(起点+终点),但实际显示时需要画成有厚度的矩形。如何从一条线精确计算出4个角点?

**为什么难**:
- 数学计算容易出错: 法向量、角度、距离计算稍有偏差就会导致墙体变形
- 浮点数精度问题: 计算机无法精确表示小数,累积误差会导致墙体"歪斜"
- 特殊角度处理: 垂直墙体(90°)、水平墙体(0°)需要特殊处理,否则可能除以零

### 常见错误

```cpp
// ❌ 错误示例: 直接用角度计算,容易出现 sin/cos 精度问题
QPointF p1 = start + QPointF(thickness * sin(angle), thickness * cos(angle));

// ❌ 错误示例: 忘记归一化向量
QLineF normal = centerLine.normalVector();
normal.setLength(thickness / 2.0);  // 这里已经归一化了,但很多人会漏掉
```

### 解决方案

**方法 1: 使用 Qt 的几何类 (推荐)**

```cpp
void WallItem::updateGeometry() {
    // 1. 创建中心线
    QLineF centerLine(m_start, m_end);

    // 2. 获取垂直向量 (Qt 自动归一化)
    QLineF perpendicular = centerLine.normalVector();
    perpendicular.setLength(m_thickness / 2.0);

    // 3. 计算4个角点
    QPointF offset(perpendicular.dx(), perpendicular.dy());

    QPointF p1 = m_start + offset;  // 起点右侧
    QPointF p2 = m_start - offset;  // 起点左侧
    QPointF p3 = m_end - offset;    // 终点左侧
    QPointF p4 = m_end + offset;    // 终点右侧

    // 4. 设置多边形
    QPolygonF polygon;
    polygon << p1 << p2 << p3 << p4;
    setPolygon(polygon);
}
```

**关键点**:
- 使用 `normalVector()` 自动计算垂直向量,避免手动 sin/cos
- `setLength()` 会自动归一化向量
- 顺序很重要: p1→p2→p3→p4 必须是逆时针或顺时针一致

**方法 2: 处理特殊情况**

```cpp
// 检查墙体是否退化成点
if (QLineF(m_start, m_end).length() < 1.0) {
    qWarning() << "墙体长度过短,无法绘制";
    return;
}

// 检查厚度是否合理
if (m_thickness < 50 || m_thickness > 1000) {
    qWarning() << "墙体厚度异常:" << m_thickness;
    m_thickness = qBound(50.0, m_thickness, 1000.0);  // 限制范围
}
```

**测试技巧**:
- 画一个水平墙体(0°),检查是否垂直向上/下
- 画一个垂直墙体(90°),检查是否水平向左/右
- 画一个斜墙体(45°),用勾股定理验证厚度

---

## 2. 墙体智能连接算法

### 难点描述

**问题**: 两段墙体在端点相遇时,如何让它们"无缝连接"? 直接重叠会有缝隙或重叠区域,需要精确计算内角点和外角点。

**为什么难**:
- **几何复杂**: L型连接(90°)需要计算斜切角,T型连接需要分割墙体
- **浮点数误差**: 判断"两点是否重合"时,不能用 `==`,要用距离阈值
- **多墙体情况**: 一个端点可能连接多段墙体(如十字交叉),需要处理优先级
- **动态更新**: 移动一段墙体时,所有相连墙体都要重新计算

### 常见错误

```cpp
// ❌ 错误示例1: 用 == 比较浮点数
if (p1 == p2) {  // 永远不会相等!
    connectWalls();
}

// ❌ 错误示例2: 忘记更新相邻墙体
void WallItem::setEndPos(const QPointF &pos) {
    m_end = pos;
    updateGeometry();  // 只更新自己,忘记通知相邻墙体!
}

// ❌ 错误示例3: 角度计算错误
qreal angle = line1.angle() - line2.angle();  // 没考虑 360° 循环
if (angle == 90) {  // 应该用 abs(angle - 90) < 5
    // L型连接
}
```

### 解决方案

**步骤 1: 判断是否需要连接**

```cpp
bool WallItem::shouldConnectTo(WallItem *other) const {
    const qreal SNAP_DISTANCE = 20.0;  // 20像素容差

    // 检查4种组合: 自己起点/终点 vs 对方起点/终点
    QList<QPair<QPointF, QPointF>> candidates = {
        {m_start, other->m_start},
        {m_start, other->m_end},
        {m_end, other->m_start},
        {m_end, other->m_end}
    };

    for (const auto &pair : candidates) {
        qreal distance = QLineF(pair.first, pair.second).length();
        if (distance < SNAP_DISTANCE) {
            return true;
        }
    }
    return false;
}
```

**步骤 2: 计算连接类型**

```cpp
enum JoinType {
    None,
    LCorner,    // L型 (约90度)
    TJunction,  // T型 (端点在中间)
    Straight    // 直线 (约180度)
};

JoinType WallItem::detectJoinType(WallItem *other) const {
    QLineF line1(m_start, m_end);
    QLineF line2(other->m_start, other->m_end);

    // 计算夹角 (处理360°循环)
    qreal angle = qAbs(line1.angle() - line2.angle());
    if (angle > 180) angle = 360 - angle;

    if (qAbs(angle - 90) < 5) {
        return LCorner;  // 90度附近 -> L型
    } else if (qAbs(angle - 180) < 5) {
        return Straight;  // 180度 -> 直线
    }
    // ... T型判断需要检查端点是否在对方中间
    return None;
}
```

**步骤 3: L型连接的角点计算 (核心难点)**

```cpp
void WallItem::computeLCornerVertices(WallItem *other, QPointF &innerCorner, QPointF &outerCorner) {
    // 假设自己的终点连接到对方的起点
    QPointF joint = (m_end + other->m_start) / 2.0;  // 连接点取中点

    // 计算两段墙的方向向量
    QLineF line1(m_start, m_end);
    QLineF line2(other->m_start, other->m_end);

    // 计算两段墙的垂直向量 (指向右侧)
    QLineF perp1 = line1.normalVector();
    perp1.setLength(m_thickness / 2.0);

    QLineF perp2 = line2.normalVector();
    perp2.setLength(other->m_thickness / 2.0);

    QPointF offset1(perp1.dx(), perp1.dy());
    QPointF offset2(perp2.dx(), perp2.dy());

    // 内角点: 两墙体内侧的交点
    QPointF inner1 = joint - offset1;  // 墙1内侧点
    QPointF inner2 = joint - offset2;  // 墙2内侧点
    innerCorner = (inner1 + inner2) / 2.0;  // 简化: 取平均

    // 外角点: 两墙体外侧的交点
    QPointF outer1 = joint + offset1;
    QPointF outer2 = joint + offset2;
    outerCorner = (outer1 + outer2) / 2.0;
}
```

**关键技巧**:
- **容差判断**: 距离 < 20px 认为重合,角度差 < 5° 认为平行
- **中点策略**: 两端点不完全重合时,取中点作为连接点
- **简化算法**: 复杂的角点计算可以先用"取平均"简化,后续优化

**调试建议**:
```cpp
// 在 paint() 中绘制调试信息
void WallItem::paint(QPainter *painter, ...) {
    // ... 正常绘制 ...

    #ifdef DEBUG_MODE
    // 绘制中心线 (红色)
    painter->setPen(QPen(Qt::red, 2));
    painter->drawLine(m_start, m_end);

    // 绘制端点 (蓝色圆圈)
    painter->setBrush(Qt::blue);
    painter->drawEllipse(m_start, 5, 5);
    painter->drawEllipse(m_end, 5, 5);

    // 显示角度
    QString angleText = QString::number(QLineF(m_start, m_end).angle(), 'f', 1);
    painter->drawText(m_start, angleText);
    #endif
}
```

---

## 3. 2D/3D 坐标系转换与同步

### 难点描述

**问题**: Qt 2D 和 OpenGL 3D 使用不同的坐标系,如何在它们之间转换? 用户在 2D 视图移动墙体,3D 视图如何实时更新?

**为什么难**:
- **坐标系差异**:
  - Qt 2D: X向右,Y向下,原点在左上角
  - OpenGL: X向右,Y向上,Z向外,原点在世界中心
- **轴映射混乱**: 2D 的 Y 对应 3D 的哪个轴? (正确答案: Z轴)
- **性能瓶颈**: 每次 2D 修改都重新生成 3D 网格,会导致卡顿
- **同步时机**: 何时触发 3D 更新? 太频繁会卡,太慢会不同步

### 常见错误

```cpp
// ❌ 错误示例1: Y轴映射错误
QVector3D to3D(const QPointF &p2d) {
    return QVector3D(p2d.x(), p2d.y(), 0);  // Y轴映射错了!
}

// ❌ 错误示例2: 忘记Y轴翻转
QVector3D to3D(const QPointF &p2d) {
    return QVector3D(p2d.x(), 0, p2d.y());  // 没考虑 Y 向下 -> Z 向外需要翻转
}

// ❌ 错误示例3: 每次鼠标移动都更新 3D
void DesignScene::mouseMoveEvent(...) {
    // ... 移动墙体 ...
    emit sceneContentChanged();  // 频繁触发,会导致 3D 卡顿!
}
```

### 解决方案

**正确的坐标转换**

```cpp
class CoordinateSystem {
public:
    // 2D -> 3D: 墙体底部顶点
    static QVector3D to3D(const QPointF &p2d, qreal height = 0) {
        return QVector3D(
            p2d.x(),           // X: 保持不变
            height,            // Y: 高度 (0=地面)
            -p2d.y()           // Z: 2D的Y向下,3D的Z向外,所以取负
        );
    }

    // 3D -> 2D: 投影到地面
    static QPointF to2D(const QVector3D &p3d) {
        return QPointF(
            p3d.x(),           // X: 保持不变
            -p3d.z()           // Y: Z 取负还原
        );
    }
};

// 使用示例: 墙体生成 3D 顶点
QVector<QVector3D> WallItem::get3DVertices() const {
    QVector<QVector3D> vertices;
    QPolygonF base = polygon();  // 2D 多边形的4个点

    // 底部4个顶点 (Y=0)
    for (const QPointF &p : base) {
        vertices << CoordinateSystem::to3D(p, 0);
    }

    // 顶部4个顶点 (Y=height)
    for (const QPointF &p : base) {
        vertices << CoordinateSystem::to3D(p, m_height);
    }

    return vertices;
}
```

**优化同步机制 (防止卡顿)**

```cpp
class DesignScene : public QGraphicsScene {
    Q_OBJECT

public:
    // 延迟更新: 100ms 内多次修改只触发一次更新
    void scheduleUpdate() {
        if (!m_updateTimer.isActive()) {
            m_updateTimer.start(100);  // 100ms 后触发
        }
    }

signals:
    void sceneContentChanged();

private slots:
    void onUpdateTimeout() {
        emit sceneContentChanged();  // 真正触发 3D 更新
    }

private:
    QTimer m_updateTimer;
};

// 使用
void DesignScene::mouseMoveEvent(QGraphicsSceneMouseEvent *event) {
    // ... 移动墙体 ...
    scheduleUpdate();  // 不直接 emit,而是延迟
}
```

**3D 视图的增量更新**

```cpp
class View3DWidget : public QOpenGLWidget {
public:
    void onSceneChanged() {
        m_needsRebuild = true;  // 标记需要重建
        update();  // 触发重绘 (下一帧才执行 paintGL)
    }

protected:
    void paintGL() override {
        if (m_needsRebuild) {
            rebuildMeshes();  // 重新生成所有网格
            m_needsRebuild = false;
        }

        // 渲染已缓存的网格
        renderCachedMeshes();
    }

private:
    bool m_needsRebuild = false;
    QVector<MeshData> m_cachedMeshes;  // 缓存网格数据
};
```

**关键要点**:
- **坐标转换**: 2D(x, y) → 3D(x, height, -y)
- **延迟更新**: 使用 100ms 定时器合并频繁修改
- **脏标志**: 用 `m_needsRebuild` 标记,避免每帧都重建
- **缓存网格**: 不变的墙体不需要重新计算顶点

**测试方法**:
```cpp
// 单元测试: 验证坐标转换
void testCoordinateConversion() {
    QPointF p2d(1000, 2000);
    QVector3D p3d = CoordinateSystem::to3D(p2d, 0);

    QCOMPARE(p3d.x(), 1000.0);
    QCOMPARE(p3d.y(), 0.0);
    QCOMPARE(p3d.z(), -2000.0);  // 注意负号

    QPointF back = CoordinateSystem::to2D(p3d);
    QCOMPARE(back, p2d);  // 往返转换应该一致
}
```

---

## 4. 吸附系统的精度与性能

### 难点描述

**问题**: 鼠标靠近墙体端点/中点/网格时自动吸附,如何做到"精准"且"流畅"?

**为什么难**:
- **吸附点太多**: 50个墙体有100个端点、100个中点,还有无数网格点
- **距离计算开销**: 每次鼠标移动都要计算到所有吸附点的距离
- **优先级冲突**: 鼠标同时靠近端点和网格,应该吸附哪个?
- **抖动问题**: 吸附阈值太小会抖动,太大会"跳跃"

### 常见错误

```cpp
// ❌ 错误示例1: 暴力搜索所有点
QPointF findSnapPoint(const QPointF &cursor) {
    qreal minDist = 999999;
    QPointF best = cursor;

    // O(n²) 复杂度!
    for (WallItem *wall : m_walls) {
        for (QPointF p : {wall->start(), wall->end(), wall->mid()}) {
            qreal dist = QLineF(cursor, p).length();
            if (dist < minDist) {
                minDist = dist;
                best = p;
            }
        }
    }
    return best;
}

// ❌ 错误示例2: 没有优先级
if (distToEndpoint < 20 || distToGrid < 20) {
    // 哪个优先? 没有明确规则!
}

// ❌ 错误示例3: 阈值固定
const qreal THRESHOLD = 10;  // 放大视图时太小,缩小时太大
```

### 解决方案

**方法 1: 空间分区 (提升性能)**

```cpp
class SpatialHash {
public:
    void insert(const QPointF &point, int id) {
        int cellX = int(point.x() / m_cellSize);
        int cellY = int(point.y() / m_cellSize);
        m_grid[{cellX, cellY}].append({point, id});
    }

    QList<SnapPoint> queryNearby(const QPointF &center, qreal radius) {
        QList<SnapPoint> result;
        int cells = int(radius / m_cellSize) + 1;
        int cx = int(center.x() / m_cellSize);
        int cy = int(center.y() / m_cellSize);

        // 只检查周围9个格子
        for (int dx = -cells; dx <= cells; ++dx) {
            for (int dy = -cells; dy <= cells; ++dy) {
                result.append(m_grid[{cx+dx, cy+dy}]);
            }
        }
        return result;
    }

private:
    qreal m_cellSize = 500;  // 每个格子 500mm
    QHash<QPair<int,int>, QList<SnapPoint>> m_grid;
};
```

**方法 2: 优先级排序**

```cpp
struct SnapPoint {
    QPointF position;
    enum Type { Endpoint, Midpoint, Grid } type;
    qreal priority;  // 数值越小优先级越高

    static qreal getPriority(Type t) {
        switch (t) {
            case Endpoint: return 1.0;    // 最高优先级
            case Midpoint: return 2.0;
            case Grid: return 3.0;        // 最低优先级
        }
    }
};

QPointF SnapEngine::findBestSnap(const QPointF &cursor, qreal tolerance) {
    // 1. 收集候选点 (使用空间分区加速)
    QList<SnapPoint> candidates = m_spatialHash.queryNearby(cursor, tolerance);

    // 2. 按距离和优先级排序
    std::sort(candidates.begin(), candidates.end(),
              [&cursor](const SnapPoint &a, const SnapPoint &b) {
        qreal distA = QLineF(cursor, a.position).length();
        qreal distB = QLineF(cursor, b.position).length();

        // 距离差不多时,按优先级
        if (qAbs(distA - distB) < 5) {
            return a.priority < b.priority;
        }
        return distA < distB;
    });

    // 3. 返回最佳点
    if (!candidates.isEmpty() &&
        QLineF(cursor, candidates.first().position).length() <= tolerance) {
        return candidates.first().position;
    }
    return cursor;  // 无吸附
}
```

**方法 3: 自适应阈值 (跟随缩放)**

```cpp
qreal SnapEngine::getAdaptiveTolerance(const QGraphicsView *view) {
    // 基础阈值: 屏幕空间 10 像素
    qreal screenTolerance = 10.0;

    // 转换到场景空间
    qreal scale = view->transform().m11();  // 获取缩放倍数
    qreal sceneTolerance = screenTolerance / scale;

    // 限制范围: 5mm - 100mm
    return qBound(5.0, sceneTolerance, 100.0);
}
```

**方法 4: 防止抖动**

```cpp
class SnapEngine {
public:
    QPointF findSnap(const QPointF &cursor, qreal tolerance) {
        QPointF newSnap = findBestSnap(cursor, tolerance);

        // 如果上一次吸附的点仍在容差范围内,保持吸附
        if (m_lastSnap.isValid()) {
            qreal distToLast = QLineF(cursor, m_lastSnap.position).length();
            if (distToLast <= tolerance * 1.2) {  // 增加 20% 粘性
                return m_lastSnap.position;  // 保持上次的吸附点
            }
        }

        m_lastSnap = {newSnap, true};
        return newSnap;
    }

private:
    struct {
        QPointF position;
        bool isValid = false;
    } m_lastSnap;
};
```

**视觉反馈**

```cpp
void DesignScene::drawForeground(QPainter *painter, const QRectF &rect) {
    QGraphicsScene::drawForeground(painter, rect);

    // 绘制吸附提示圈
    if (m_currentSnapPoint.isValid()) {
        painter->setPen(QPen(QColor(24, 144, 255), 2));  // 蓝色
        painter->setBrush(Qt::NoBrush);
        painter->drawEllipse(m_currentSnapPoint.position, 8, 8);

        // 绘制十字线
        qreal crossSize = 15;
        painter->drawLine(m_currentSnapPoint.position - QPointF(crossSize, 0),
                         m_currentSnapPoint.position + QPointF(crossSize, 0));
        painter->drawLine(m_currentSnapPoint.position - QPointF(0, crossSize),
                         m_currentSnapPoint.position + QPointF(0, crossSize));
    }
}
```

**关键优化**:
- **空间分区**: 将画布分成格子,只检查附近的点 (复杂度从 O(n) 降到 O(1))
- **优先级**: 端点 > 中点 > 网格
- **自适应阈值**: 根据缩放级别动态调整
- **粘性吸附**: 增加 20% 的"黏性"防止抖动

---

## 5. 门窗开洞算法

### 难点描述

**问题**: 墙体是实心的矩形,如何在上面"挖洞"放置门窗?

**为什么难**:
- **2D 简单但不真实**: 直接用白色矩形遮挡,3D 中墙体仍是实心的
- **3D 真实但复杂**: 需要布尔运算 (CSG),算法复杂且性能差
- **多个开洞**: 一面墙有2扇窗+1个门,如何处理重叠和间隙?
- **性能瓶颈**: 每次门窗移动都要重新切割墙体,会卡顿

### 常见错误

```cpp
// ❌ 错误示例1: 2D 遮挡不考虑层级
void OpeningItem::paint(QPainter *painter, ...) {
    painter->fillRect(boundingRect(), Qt::white);  // 可能被墙体覆盖!
}

// ❌ 错误示例2: 3D 开洞没有排序
for (OpeningItem *opening : wall->openings()) {
    cutHole(opening);  // 开洞顺序错误会导致重叠
}

// ❌ 错误示例3: 每帧都重新计算布尔运算
void View3DWidget::paintGL() {
    for (WallItem *wall : walls) {
        MeshData mesh = generateWallWithCSG(wall);  // 太慢!
        render(mesh);
    }
}
```

### 解决方案

**方法 1: 2D 图层遮挡 (简单有效)**

```cpp
class OpeningItem : public QGraphicsItem {
public:
    OpeningItem() {
        setZValue(100);  // 确保在墙体 (ZValue=0) 之上
        setFlag(QGraphicsItem::ItemIsSelectable);
    }

    void paint(QPainter *painter, ...) override {
        // 1. 绘制白色背景 (遮挡墙体线条)
        painter->setBrush(Qt::white);
        painter->setPen(Qt::NoPen);
        painter->drawRect(boundingRect().adjusted(-2, -2, 2, 2));  // 稍微大一点

        // 2. 绘制门窗符号
        painter->setPen(QPen(Qt::black, 2));
        if (m_type == Door) {
            drawDoorSymbol(painter);
        } else {
            drawWindowSymbol(painter);
        }
    }
};
```

**方法 2: 3D 分段渲染 (推荐,性能好)**

```cpp
void View3DWidget::renderWallWithOpenings(WallItem *wall) {
    qreal totalLength = QLineF(wall->startPos(), wall->endPos()).length();
    QList<OpeningItem*> openings = wall->openings();

    // 1. 对开洞按位置排序
    std::sort(openings.begin(), openings.end(),
              [](OpeningItem *a, OpeningItem *b) {
        return a->distanceFromStart() < b->distanceFromStart();
    });

    // 2. 分段渲染
    qreal lastEnd = 0;
    for (OpeningItem *opening : openings) {
        qreal openStart = opening->distanceFromStart();
        qreal openEnd = openStart + opening->width();

        // 渲染 [lastEnd, openStart] 段 (实心墙体)
        if (openStart > lastEnd) {
            renderWallSegment(wall, lastEnd, openStart);
        }

        // 跳过 [openStart, openEnd] 段 (开洞区域)

        // 渲染门窗框架
        renderOpeningFrame(wall, opening, openStart);

        lastEnd = openEnd;
    }

    // 3. 渲染最后一段
    if (lastEnd < totalLength) {
        renderWallSegment(wall, lastEnd, totalLength);
    }
}

void View3DWidget::renderWallSegment(WallItem *wall, qreal start, qreal end) {
    // 计算起点和终点的 3D 坐标
    QLineF centerLine(wall->startPos(), wall->endPos());
    qreal totalLen = centerLine.length();

    QPointF p1 = centerLine.pointAt(start / totalLen);  // 段起点
    QPointF p2 = centerLine.pointAt(end / totalLen);    // 段终点

    // 生成立方体网格
    MeshData mesh = generateCuboid(p1, p2, wall->thickness(), wall->height());

    // 渲染
    uploadAndRender(mesh);
}
```

**方法 3: CSG 布尔运算 (精确但慢,可选)**

```cpp
#include <CGAL/...>  // 需要引入 CGAL 库

MeshData View3DWidget::generateWallWithCSG(WallItem *wall) {
    // 1. 生成墙体基础 Mesh
    MeshData wallMesh = generateCuboid(
        wall->startPos(), wall->endPos(),
        wall->thickness(), wall->height()
    );

    // 2. 对每个开洞执行布尔减法
    for (OpeningItem *opening : wall->openings()) {
        // 生成开洞的立方体
        MeshData holeMesh = generateOpeningHole(wall, opening);

        // CSG 减法: wallMesh = wallMesh - holeMesh
        wallMesh = CGAL_Subtract(wallMesh, holeMesh);
    }

    return wallMesh;
}
```

**性能优化: 缓存机制**

```cpp
class View3DWidget {
private:
    struct WallMeshCache {
        WallItem *wall;
        int openingCount;
        quint64 lastModified;
        MeshData mesh;
    };
    QHash<WallItem*, WallMeshCache> m_wallMeshCache;

public:
    MeshData getWallMesh(WallItem *wall) {
        auto it = m_wallMeshCache.find(wall);

        // 检查缓存是否有效
        bool cacheValid = (it != m_wallMeshCache.end() &&
                          it->openingCount == wall->openings().size() &&
                          it->lastModified == wall->lastModifiedTime());

        if (cacheValid) {
            return it->mesh;  // 直接返回缓存
        }

        // 重新生成
        MeshData mesh = renderWallWithOpenings(wall);
        m_wallMeshCache[wall] = {
            wall,
            wall->openings().size(),
            wall->lastModifiedTime(),
            mesh
        };
        return mesh;
    }
};
```

**推荐方案总结**:
- **2D**: 图层遮挡 (ZValue 控制)
- **3D**: 分段渲染 (性能好,效果足够)
- **高级**: CSG + 缓存 (精确但需要额外库)

---

## 6. OpenGL 渲染性能优化

### 难点描述

**问题**: 场景有 1000 个墙体 + 500 个家具,如何保持 30fps 以上的流畅渲染?

**为什么难**:
- **Draw Call 过多**: 每个墙体一个 Draw Call,1000 个墙体 = 1000 次 GPU 调用
- **重复传输数据**: 每帧都把顶点数据从 CPU 传到 GPU,浪费带宽
- **CPU 瓶颈**: 遍历所有对象、计算矩阵、准备数据占用大量 CPU 时间
- **显存溢出**: 1000 个模型可能占用几百 MB 显存

### 常见错误

```cpp
// ❌ 错误示例1: 每个墙体单独渲染
for (WallItem *wall : walls) {
    MeshData mesh = wall->generateMesh();  // 每帧都计算!

    m_vbo.bind();
    m_vbo.allocate(mesh.vertices.data(), mesh.vertices.size() * sizeof(float));
    glDrawArrays(GL_TRIANGLES, 0, mesh.vertices.size() / 3);
}
// 问题: 1000 个墙体 = 1000 次 glDrawArrays 调用

// ❌ 错误示例2: 没有使用 VAO
void paintGL() {
    glBindBuffer(GL_ARRAY_BUFFER, vbo);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);  // 每帧都设置一次!
    glEnableVertexAttribArray(0);
    glDrawArrays(...);
}

// ❌ 错误示例3: 每帧都更新所有 Uniform
for (WallItem *wall : walls) {
    m_shader->setUniformValue("model", wall->matrix());  // 1000次调用!
    glDrawArrays(...);
}
```

### 解决方案

**优化 1: 批量渲染 (Batch Rendering)**

```cpp
class View3DWidget {
private:
    struct BatchMesh {
        QVector<GLfloat> vertices;  // 所有墙体合并
        QVector<GLuint> indices;
        int count = 0;
    };
    BatchMesh m_wallBatch;
    bool m_batchDirty = true;

public:
    void rebuildWallBatch() {
        m_wallBatch.vertices.clear();
        m_wallBatch.indices.clear();

        int vertexOffset = 0;
        for (WallItem *wall : m_scene->walls()) {
            QVector<QVector3D> verts = wall->get3DVertices();

            // 添加顶点
            for (const QVector3D &v : verts) {
                m_wallBatch.vertices << v.x() << v.y() << v.z();
            }

            // 添加索引 (两个三角形组成一个面)
            for (int i = 0; i < 6; ++i) {  // 6个面
                m_wallBatch.indices << vertexOffset + faceIndices[i][0];
                m_wallBatch.indices << vertexOffset + faceIndices[i][1];
                m_wallBatch.indices << vertexOffset + faceIndices[i][2];
            }

            vertexOffset += verts.size();
        }

        m_wallBatch.count = m_wallBatch.indices.size();
        m_batchDirty = false;
    }

    void paintGL() override {
        if (m_batchDirty) {
            rebuildWallBatch();
        }

        // 上传到 GPU (只传输一次)
        m_vbo.bind();
        m_vbo.allocate(m_wallBatch.vertices.constData(),
                       m_wallBatch.vertices.size() * sizeof(GLfloat));

        m_ibo.bind();
        m_ibo.allocate(m_wallBatch.indices.constData(),
                       m_wallBatch.indices.size() * sizeof(GLuint));

        // 一次 Draw Call 渲染所有墙体!
        glDrawElements(GL_TRIANGLES, m_wallBatch.count, GL_UNSIGNED_INT, 0);
    }
};
```

**优化 2: 使用 VAO 减少状态切换**

```cpp
class View3DWidget {
private:
    QOpenGLVertexArrayObject m_wallVAO;
    QOpenGLBuffer m_wallVBO;
    QOpenGLBuffer m_wallIBO;

public:
    void initializeGL() override {
        // 创建 VAO
        m_wallVAO.create();
        m_wallVAO.bind();

        // 创建并绑定 VBO
        m_wallVBO.create();
        m_wallVBO.bind();
        m_wallVBO.setUsagePattern(QOpenGLBuffer::DynamicDraw);

        // 创建并绑定 IBO
        m_wallIBO.create();
        m_wallIBO.bind();
        m_wallIBO.setUsagePattern(QOpenGLBuffer::StaticDraw);

        // 设置顶点属性 (只需要设置一次!)
        m_shaderProgram->bind();
        m_shaderProgram->enableAttributeArray("position");
        m_shaderProgram->setAttributeBuffer("position", GL_FLOAT, 0, 3);

        m_wallVAO.release();
    }

    void paintGL() override {
        m_wallVAO.bind();  // 所有状态已保存在 VAO 中
        glDrawElements(GL_TRIANGLES, m_wallBatch.count, GL_UNSIGNED_INT, 0);
        m_wallVAO.release();
    }
};
```

**优化 3: 视锥剔除 (Frustum Culling)**

```cpp
bool View3DWidget::isInFrustum(const QRectF &bounds) {
    // 计算视锥体 (简化版)
    QMatrix4x4 mvp = m_projectionMatrix * m_viewMatrix;

    // 将 2D 边界框转换到 3D
    QVector<QVector3D> corners = {
        QVector3D(bounds.left(), 0, bounds.top()),
        QVector3D(bounds.right(), 0, bounds.top()),
        QVector3D(bounds.right(), 0, bounds.bottom()),
        QVector3D(bounds.left(), 0, bounds.bottom()),
    };

    // 检查至少一个角点在视锥内
    for (const QVector3D &corner : corners) {
        QVector4D clip = mvp * QVector4D(corner, 1.0);
        if (qAbs(clip.x()) <= clip.w() &&
            qAbs(clip.y()) <= clip.w() &&
            qAbs(clip.z()) <= clip.w()) {
            return true;  // 在视锥内
        }
    }
    return false;
}

void View3DWidget::paintGL() {
    int culledCount = 0;
    for (WallItem *wall : m_scene->walls()) {
        if (!isInFrustum(wall->boundingRect())) {
            culledCount++;
            continue;  // 跳过不可见的墙体
        }
        renderWall(wall);
    }
    qDebug() << "剔除" << culledCount << "个墙体";
}
```

**优化 4: LOD (Level of Detail)**

```cpp
class FurnitureItem {
public:
    QString getModelPath(int lod) const {
        switch (lod) {
            case 0: return m_assetId + "_high.obj";    // 高精度 (5000 面)
            case 1: return m_assetId + "_medium.obj";  // 中精度 (1000 面)
            case 2: return m_assetId + "_low.obj";     // 低精度 (200 面)
        }
    }
};

void View3DWidget::renderFurniture(FurnitureItem *item) {
    // 计算距离相机的距离
    QVector3D pos = CoordinateSystem::to3D(item->pos());
    qreal distance = (m_cameraPos - pos).length();

    // 根据距离选择 LOD 级别
    int lod = 0;
    if (distance > 10000) lod = 2;       // 远距离: 低精度
    else if (distance > 5000) lod = 1;   // 中距离: 中精度
    else lod = 0;                        // 近距离: 高精度

    QString modelPath = item->getModelPath(lod);
    MeshData mesh = m_modelCache.get(modelPath);

    renderMesh(mesh, item->transformMatrix());
}
```

**优化 5: 模型缓存**

```cpp
class ModelCache {
public:
    static ModelCache* instance() {
        static ModelCache cache;
        return &cache;
    }

    MeshData get(const QString &path) {
        // 检查缓存
        if (m_cache.contains(path)) {
            return m_cache[path];
        }

        // 加载模型
        MeshData mesh = loadModel(path);
        m_cache[path] = mesh;

        qDebug() << "缓存模型:" << path
                 << "顶点数:" << mesh.vertices.size() / 3;

        return mesh;
    }

    void clear() {
        m_cache.clear();
    }

private:
    QHash<QString, MeshData> m_cache;
};
```

**性能对比**:
| 优化前 | 优化后 |
|--------|--------|
| 1000 个 Draw Call | 1 个 Draw Call (批量渲染) |
| 每帧设置顶点属性 | VAO 保存状态 |
| 渲染所有对象 | 视锥剔除 60% |
| 远处也用高精度模型 | LOD 降低面数 80% |
| 每次加载模型 | 缓存复用 |
| **帧率: 10fps** | **帧率: 60fps** |

---

## 7. 撤销/重做系统设计

### 难点描述

**问题**: 用户移动墙体后按 Ctrl+Z 撤销,如何准确恢复到之前的状态?

**为什么难**:
- **状态复杂**: 墙体有位置、厚度、高度、连接关系等多个状态
- **关联对象**: 撤销删除墙体时,依附的门窗也要恢复
- **内存占用**: 保存所有历史状态会占用大量内存
- **合并操作**: 连续小改动 (如拖拽) 应该合并成一次撤销

### 常见错误

```cpp
// ❌ 错误示例1: 直接保存对象指针
class MoveCommand : public QUndoCommand {
    WallItem *m_wall;  // 危险! 如果墙体被删除,指针悬空
    QPointF m_oldPos, m_newPos;
};

// ❌ 错误示例2: 没有处理关联对象
void DeleteWallCommand::undo() {
    scene->addWall(m_wall);  // 墙体恢复了,但门窗丢失!
}

// ❌ 错误示例3: 没有合并连续操作
void mouseMoveEvent(...) {
    // 鼠标移动 100 次 = 100 个 MoveCommand,撤销要按 100 次!
    undoStack->push(new MoveCommand(wall, oldPos, newPos));
}
```

### 解决方案

**基础命令设计**

```cpp
class Command : public QUndoCommand {
public:
    Command(DesignScene *scene, const QString &text)
        : QUndoCommand(text), m_scene(scene) {}

protected:
    DesignScene *m_scene;  // 场景指针 (稳定)
};

// 添加墙体命令
class AddWallCommand : public Command {
public:
    AddWallCommand(DesignScene *scene, const QJsonObject &wallData)
        : Command(scene, "添加墙体"),
          m_wallData(wallData),  // 保存 JSON 数据而非指针!
          m_wallId(wallData["id"].toString()) {}

    void undo() override {
        WallItem *wall = m_scene->findWall(m_wallId);
        if (wall) {
            m_scene->removeWall(wall);
            delete wall;  // 删除对象
        }
    }

    void redo() override {
        WallItem *wall = WallItem::fromJson(m_wallData);  // 从数据重建
        m_scene->addWall(wall);
    }

private:
    QJsonObject m_wallData;  // 保存数据而非指针
    QString m_wallId;
};
```

**处理关联对象**

```cpp
class DeleteWallCommand : public Command {
public:
    DeleteWallCommand(DesignScene *scene, WallItem *wall)
        : Command(scene, "删除墙体") {

        // 保存墙体数据
        m_wallData = wall->toJson();

        // 保存依附的门窗数据
        for (OpeningItem *opening : wall->openings()) {
            m_openingsData.append(opening->toJson());
        }
    }

    void undo() override {
        // 1. 恢复墙体
        WallItem *wall = WallItem::fromJson(m_wallData);
        m_scene->addWall(wall);

        // 2. 恢复门窗
        for (const QJsonObject &data : m_openingsData) {
            OpeningItem *opening = OpeningItem::fromJson(data);
            wall->addOpening(opening);
            m_scene->addItem(opening);
        }
    }

    void redo() override {
        WallItem *wall = m_scene->findWall(m_wallData["id"].toString());
        if (wall) {
            // 先删除门窗
            for (OpeningItem *opening : wall->openings()) {
                m_scene->removeItem(opening);
                delete opening;
            }
            // 再删除墙体
            m_scene->removeWall(wall);
            delete wall;
        }
    }

private:
    QJsonObject m_wallData;
    QList<QJsonObject> m_openingsData;
};
```

**合并连续操作**

```cpp
class MoveItemCommand : public Command {
public:
    MoveItemCommand(DesignScene *scene, const QString &itemId,
                    const QPointF &oldPos, const QPointF &newPos)
        : Command(scene, "移动对象"),
          m_itemId(itemId), m_oldPos(oldPos), m_newPos(newPos) {}

    // 关键: 实现 mergeWith 合并连续移动
    bool mergeWith(const QUndoCommand *other) override {
        const MoveItemCommand *cmd = static_cast<const MoveItemCommand*>(other);

        // 只合并同一个对象的移动
        if (cmd->m_itemId != m_itemId) {
            return false;
        }

        // 更新终点位置
        m_newPos = cmd->m_newPos;
        return true;  // 合并成功
    }

    int id() const override { return 1001; }  // 相同 ID 才能合并

    void undo() override {
        QGraphicsItem *item = m_scene->findItem(m_itemId);
        if (item) item->setPos(m_oldPos);
    }

    void redo() override {
        QGraphicsItem *item = m_scene->findItem(m_itemId);
        if (item) item->setPos(m_newPos);
    }

private:
    QString m_itemId;
    QPointF m_oldPos, m_newPos;
};

// 使用时设置合并时间窗口
undoStack->setUndoLimit(50);  // 最多保存 50 步
```

**集成到 UI**

```cpp
class MainWindow : public QMainWindow {
public:
    MainWindow() {
        m_undoStack = new QUndoStack(this);

        // 创建撤销/重做动作
        QAction *undoAction = m_undoStack->createUndoAction(this, tr("撤销"));
        undoAction->setShortcut(QKeySequence::Undo);  // Ctrl+Z
        undoAction->setIcon(QIcon(":/icons/undo.png"));

        QAction *redoAction = m_undoStack->createRedoAction(this, tr("重做"));
        redoAction->setShortcut(QKeySequence::Redo);  // Ctrl+Y
        redoAction->setIcon(QIcon(":/icons/redo.png"));

        // 添加到工具栏
        m_toolbar->addAction(undoAction);
        m_toolbar->addAction(redoAction);

        // 添加到菜单
        m_editMenu->addAction(undoAction);
        m_editMenu->addAction(redoAction);

        // 显示命令名称
        connect(m_undoStack, &QUndoStack::canUndoChanged, this, [=](bool canUndo) {
            if (canUndo) {
                QString text = m_undoStack->undoText();  // "添加墙体"
                undoAction->setText(tr("撤销: %1").arg(text));
            }
        });
    }

private:
    QUndoStack *m_undoStack;
};
```

**内存优化**

```cpp
// 限制撤销栈深度
undoStack->setUndoLimit(50);  // 最多 50 步

// 清理旧命令
class SmartUndoStack : public QUndoStack {
public:
    void push(QUndoCommand *cmd) override {
        // 检查内存占用
        if (m_memoryUsage > 100 * 1024 * 1024) {  // 100MB
            setUndoLimit(25);  // 减少限制
        }

        QUndoStack::push(cmd);
        m_memoryUsage += estimateCommandSize(cmd);
    }

private:
    qint64 m_memoryUsage = 0;

    qint64 estimateCommandSize(QUndoCommand *cmd) {
        // 估算命令占用内存 (简化)
        return 1024;  // 假设每个命令 1KB
    }
};
```

**关键要点**:
- **保存数据不保存指针**: 用 JSON 序列化状态
- **处理关联对象**: 删除墙体时同时保存门窗
- **合并连续操作**: 实现 `mergeWith()` 和 `id()`
- **限制内存**: 设置 `undoLimit` 和定期清理

---

## 8. 内存管理与资源泄漏

### 难点描述

**问题**: 长时间运行软件,内存占用越来越高,最终崩溃或卡顿。

**为什么难**:
- **Qt 对象树不够用**: QGraphicsItem 不在 QObject 树中,需要手动管理
- **循环引用**: 墙体引用门窗,门窗引用墙体,谁负责删除?
- **OpenGL 资源**: VBO、纹理等需要显式释放,否则显存泄漏
- **信号槽连接**: 对象删除后连接未断开,导致野指针访问

### 常见错误

```cpp
// ❌ 错误示例1: 忘记删除 QGraphicsItem
void DesignScene::clear() {
    QGraphicsScene::clear();  // 只清空场景,不删除对象!
    // WallItem 对象仍在内存中!
}

// ❌ 错误示例2: 重复删除
WallItem *wall = new WallItem();
scene->addWall(wall);
// ...
delete wall;  // 第一次删除
scene->removeWall(wall);  // scene 内部可能再次删除 -> 崩溃!

// ❌ 错误示例3: 信号槽未断开
connect(wall, &WallItem::positionChanged, this, &View3D::update);
delete wall;  // wall 删除了
// 但如果 wall 之前发射信号,this->update() 可能访问野指针!

// ❌ 错误示例4: OpenGL 资源未释放
void View3DWidget::loadModel() {
    GLuint vbo;
    glGenBuffers(1, &vbo);
    // ... 使用 vbo ...
    // 忘记 glDeleteBuffers(1, &vbo);
}
```

### 解决方案

**规则 1: 明确所有权**

```cpp
class DesignScene : public QGraphicsScene {
public:
    void addWall(WallItem *wall) {
        m_walls.append(wall);
        addItem(wall);  // QGraphicsScene 管理绘制

        // ✅ 重要: 设置父对象 (可选,但推荐)
        wall->setParentItem(nullptr);  // 如果有父 Item
    }

    void removeWall(WallItem *wall) {
        m_walls.removeOne(wall);
        removeItem(wall);
        delete wall;  // ✅ 明确: Scene 负责删除
    }

    ~DesignScene() {
        // ✅ 析构时清理所有对象
        qDeleteAll(m_walls);
        m_walls.clear();
    }

private:
    QList<WallItem*> m_walls;  // Scene 拥有所有权
};
```

**规则 2: 使用智能指针 (推荐)**

```cpp
class DesignScene : public QGraphicsScene {
public:
    void addWall(WallItem *wall) {
        // 转移到智能指针管理
        m_walls.append(QSharedPointer<WallItem>(wall));
        addItem(wall);
    }

    void removeWall(WallItem *wall) {
        for (int i = 0; i < m_walls.size(); ++i) {
            if (m_walls[i].data() == wall) {
                removeItem(wall);
                m_walls.removeAt(i);  // 智能指针自动删除
                break;
            }
        }
    }

private:
    QList<QSharedPointer<WallItem>> m_walls;  // ✅ 自动管理生命周期
};
```

**规则 3: 处理循环引用**

```cpp
class WallItem : public QGraphicsPolygonItem {
public:
    void addOpening(OpeningItem *opening) {
        m_openings.append(opening);
        opening->setWall(this);  // 反向引用
    }

    ~WallItem() {
        // ✅ 删除墙体时同时删除门窗
        qDeleteAll(m_openings);
        m_openings.clear();
    }

private:
    QList<OpeningItem*> m_openings;  // 拥有所有权
};

class OpeningItem : public QGraphicsItem {
public:
    void setWall(WallItem *wall) {
        m_wall = wall;  // ✅ 弱引用,不负责删除
    }

    WallItem* wall() const { return m_wall; }

private:
    WallItem *m_wall;  // 不拥有所有权,仅引用
};
```

**规则 4: 信号槽安全**

```cpp
class View3DWidget : public QOpenGLWidget {
public:
    void setScene(DesignScene *scene) {
        // 断开旧连接
        if (m_scene) {
            disconnect(m_scene, nullptr, this, nullptr);
        }

        m_scene = scene;

        // ✅ 使用 Qt::UniqueConnection 防止重复连接
        connect(m_scene, &DesignScene::sceneContentChanged,
                this, &View3DWidget::onSceneChanged,
                Qt::UniqueConnection);
    }

    ~View3DWidget() {
        // ✅ 析构时断开所有连接 (Qt 会自动做,但显式更安全)
        if (m_scene) {
            disconnect(m_scene, nullptr, this, nullptr);
        }
    }
};
```

**规则 5: OpenGL 资源管理**

```cpp
class View3DWidget : public QOpenGLWidget {
public:
    void initializeGL() override {
        // 创建 VBO
        m_vbo.create();
        m_vbo.bind();
        // ...
    }

    ~View3DWidget() {
        // ✅ 必须在 OpenGL 上下文中释放资源
        makeCurrent();  // 激活上下文

        m_vbo.destroy();
        m_ibo.destroy();

        delete m_shaderProgram;
        m_shaderProgram = nullptr;

        doneCurrent();  // 释放上下文
    }

private:
    QOpenGLBuffer m_vbo;
    QOpenGLBuffer m_ibo;
    QOpenGLShaderProgram *m_shaderProgram = nullptr;
};
```

**检测工具**

```bash
# Windows: Dr. Memory
drmemory.exe -- QtPlanArchitect.exe

# Linux: Valgrind
valgrind --leak-check=full ./QtPlanArchitect

# Qt 自带工具
export QT_FATAL_WARNINGS=1  # 将警告变成崩溃,方便发现问题
```

**内存泄漏排查清单**:
- [ ] 所有 `new` 都有对应的 `delete`
- [ ] QGraphicsItem 在场景 clear() 时被删除
- [ ] 信号槽在对象删除前断开
- [ ] OpenGL 资源在析构时释放
- [ ] 智能指针没有循环引用
- [ ] 定时器在对象删除时停止

---

## 9. 数据序列化与版本兼容

### 难点描述

**问题**: 用户用 V1.0 保存的项目,升级到 V1.1 后无法打开,或者数据丢失。

**为什么难**:
- **字段变更**: V1.1 新增了 "墙体材质" 字段,V1.0 的文件没有这个字段
- **类型变更**: 原来的 `thickness` 是整数,现在改成浮点数
- **结构变更**: 门窗从独立存储改为依附在墙体上
- **向后兼容**: 新版本要能读取旧文件,但旧版本无法读取新文件

### 常见错误

```cpp
// ❌ 错误示例1: 没有版本号
QJsonObject WallItem::toJson() const {
    return {
        {"start", QJsonArray{m_start.x(), m_start.y()}},
        {"end", QJsonArray{m_end.x(), m_end.y()}},
        {"thickness", m_thickness}
        // 没有版本号,将来无法判断格式!
    };
}

// ❌ 错误示例2: 直接访问字段不检查
WallItem* WallItem::fromJson(const QJsonObject &json) {
    qreal thickness = json["thickness"].toDouble();  // 如果字段不存在会返回 0!
    // ...
}

// ❌ 错误示例3: 枚举值直接保存数字
json["type"] = int(m_type);  // 如果枚举顺序变了,会读错!
```

### 解决方案

**方案 1: 版本号管理**

```cpp
// 定义版本号常量
namespace FileFormat {
    constexpr int MAJOR = 1;
    constexpr int MINOR = 1;
    constexpr int PATCH = 0;

    QString version() {
        return QString("%1.%2.%3").arg(MAJOR).arg(MINOR).arg(PATCH);
    }
}

// 保存时写入版本号
QJsonObject DesignScene::toJson() const {
    QJsonObject root;

    // 1. 项目信息 (必须包含版本号!)
    root["project_info"] = QJsonObject{
        {"version", FileFormat::version()},
        {"created_at", QDateTime::currentDateTime().toString(Qt::ISODate)},
        {"app_name", "QtPlanArchitect"}
    };

    // 2. 设置
    root["settings"] = /* ... */;

    // 3. 数据
    root["walls"] = /* ... */;

    return root;
}

// 加载时检查版本号
void DesignScene::fromJson(const QJsonObject &root) {
    // 读取版本号
    QJsonObject info = root["project_info"].toObject();
    QString version = info["version"].toString();

    if (version.isEmpty()) {
        qWarning() << "未知版本,尝试作为 V1.0 解析";
        version = "1.0.0";
    }

    // 按版本解析
    if (version.startsWith("1.0")) {
        loadVersion_1_0(root);
    } else if (version.startsWith("1.1")) {
        loadVersion_1_1(root);
    } else {
        throw std::runtime_error("不支持的文件版本: " + version.toStdString());
    }
}
```

**方案 2: 字段默认值**

```cpp
WallItem* WallItem::fromJson(const QJsonObject &json) {
    // ✅ 使用 value() 提供默认值
    QPointF start(
        json["start"].toArray()[0].toDouble(0),
        json["start"].toArray()[1].toDouble(0)
    );

    qreal thickness = json.value("thickness", 240).toDouble();  // 默认 240
    qreal height = json.value("height", 2800).toDouble();       // 默认 2800

    // ✅ V1.1 新增字段 (V1.0 文件没有)
    QString material = json.value("material", "concrete").toString();

    WallItem *wall = new WallItem(start, end);
    wall->setThickness(thickness);
    wall->setHeight(height);
    wall->setMaterial(material);  // 新字段,V1.0 会使用默认值

    return wall;
}
```

**方案 3: 迁移函数**

```cpp
class DesignScene {
private:
    // V1.0 → V1.1 迁移
    QJsonObject migrateFrom_1_0_to_1_1(const QJsonObject &old) {
        QJsonObject updated = old;

        // 1. 添加新字段默认值
        QJsonArray walls = updated["walls"].toArray();
        for (int i = 0; i < walls.size(); ++i) {
            QJsonObject wall = walls[i].toObject();

            // V1.1 新增 "material" 字段
            if (!wall.contains("material")) {
                wall["material"] = "concrete";
            }

            // V1.1 将 thickness 从 int 改为 double
            if (wall.contains("thickness")) {
                wall["thickness"] = wall["thickness"].toInt() * 1.0;
            }

            walls[i] = wall;
        }
        updated["walls"] = walls;

        // 2. 更新版本号
        QJsonObject info = updated["project_info"].toObject();
        info["version"] = "1.1.0";
        info["migrated_from"] = "1.0.0";
        updated["project_info"] = info;

        return updated;
    }

    void loadVersion_1_0(const QJsonObject &root) {
        // 先迁移到 1.1 格式
        QJsonObject migrated = migrateFrom_1_0_to_1_1(root);

        // 再用 1.1 的加载逻辑
        loadVersion_1_1(migrated);
    }
};
```

**方案 4: 枚举值用字符串**

```cpp
// ❌ 不要用数字
json["type"] = int(m_type);  // 0, 1, 2...

// ✅ 用字符串
QString typeToString(Type type) {
    switch (type) {
        case Door: return "door";
        case Window: return "window";
        default: return "unknown";
    }
}

Type stringToType(const QString &str) {
    if (str == "door") return Door;
    if (str == "window") return Window;
    return Door;  // 默认值
}

QJsonObject OpeningItem::toJson() const {
    return {
        {"type", typeToString(m_type)},
        // ...
    };
}
```

**方案 5: 向后兼容警告**

```cpp
void DesignScene::fromJson(const QJsonObject &root) {
    QString version = root["project_info"].toObject()["version"].toString();

    // 解析主版本号
    int major = version.split('.')[0].toInt();

    if (major > FileFormat::MAJOR) {
        QMessageBox::warning(nullptr, "版本警告",
            QString("文件版本 (%1) 高于当前软件版本 (%2),可能无法正确读取某些数据。\n"
                    "建议升级软件到最新版本。")
            .arg(version).arg(FileFormat::version()));
    }

    // 继续加载,尽力而为
}
```

**测试策略**

```cpp
void testVersionCompatibility() {
    // 1. 生成 V1.0 测试文件
    QJsonObject v1_0 = {
        {"project_info", QJsonObject{{"version", "1.0.0"}}},
        {"walls", QJsonArray{
            QJsonObject{
                {"start", QJsonArray{0, 0}},
                {"end", QJsonArray{5000, 0}},
                {"thickness", 240}  // V1.0: int
                // 没有 "material" 字段
            }
        }}
    };

    // 2. 用 V1.1 加载
    DesignScene scene;
    scene.fromJson(v1_0);

    // 3. 验证数据
    WallItem *wall = scene.walls().first();
    QCOMPARE(wall->thickness(), 240.0);  // int → double
    QCOMPARE(wall->material(), QString("concrete"));  // 默认值
}
```

**关键要点**:
- **必须有版本号**: 每个文件都要记录格式版本
- **默认值**: 新字段使用 `value(key, default)`
- **迁移函数**: V1.0 → V1.1 → V1.2 逐步迁移
- **字符串枚举**: 不用数字表示枚举
- **友好提示**: 版本不兼容时给出明确提示

---

## 10. 用户交互的响应性

### 难点描述

**问题**: 用户拖拽墙体时画面卡顿,鼠标跟不上,体验很差。

**为什么难**:
- **主线程阻塞**: 耗时操作 (如生成 3D 网格) 在主线程执行
- **过度绘制**: 每次鼠标移动都重绘整个场景
- **无节流**: 鼠标移动事件每秒触发 100+ 次
- **同步操作**: 等待文件 I/O、网络请求阻塞 UI

### 常见错误

```cpp
// ❌ 错误示例1: 主线程耗时操作
void DesignScene::mouseMoveEvent(QGraphicsSceneMouseEvent *event) {
    m_tempWall->setEndPos(event->scenePos());
    m_tempWall->updateGeometry();  // 计算几何

    // 立即触发 3D 更新 (可能耗时 50ms!)
    emit sceneContentChanged();  // 阻塞主线程!
}

// ❌ 错误示例2: 同步文件加载
void MainWindow::openFile(const QString &path) {
    QFile file(path);
    file.open(QIODevice::ReadOnly);
    QByteArray data = file.readAll();  // 大文件可能卡顿 1-2 秒

    QJsonDocument doc = QJsonDocument::fromJson(data);
    m_scene->fromJson(doc.object());  // 解析也很慢
}

// ❌ 错误示例3: 无限制重绘
void WallItem::setPos(const QPointF &pos) {
    QGraphicsItem::setPos(pos);
    update();  // 每次移动都重绘
}
```

### 解决方案

**优化 1: 事件节流**

```cpp
class DesignScene : public QGraphicsScene {
public:
    DesignScene() {
        // 延迟更新定时器
        m_updateTimer.setSingleShot(true);
        m_updateTimer.setInterval(16);  // 60fps = 16ms
        connect(&m_updateTimer, &QTimer::timeout, this, [this]() {
            emit sceneContentChanged();
        });
    }

    void mouseMoveEvent(QGraphicsSceneMouseEvent *event) override {
        // 更新临时墙体
        if (m_tempWall) {
            m_tempWall->setEndPos(event->scenePos());
        }

        // 不立即发射信号,而是启动定时器
        if (!m_updateTimer.isActive()) {
            m_updateTimer.start();  // 16ms 后才触发
        }

        // 2D 视图立即更新 (轻量级)
        update(event->scenePos().toRect().adjusted(-50, -50, 50, 50));
    }

private:
    QTimer m_updateTimer;
};
```

**优化 2: 异步加载**

```cpp
class MainWindow : public QMainWindow {
public:
    void openFileAsync(const QString &path) {
        // 显示进度对话框
        QProgressDialog *progress = new QProgressDialog(
            "正在加载项目...", "取消", 0, 0, this);
        progress->setWindowModality(Qt::WindowModal);
        progress->show();

        // 在后台线程加载
        QFuture<QJsonObject> future = QtConcurrent::run([path]() {
            QFile file(path);
            file.open(QIODevice::ReadOnly);
            QByteArray data = file.readAll();
            return QJsonDocument::fromJson(data).object();
        });

        // 监听完成
        QFutureWatcher<QJsonObject> *watcher = new QFutureWatcher<QJsonObject>(this);
        connect(watcher, &QFutureWatcher<QJsonObject>::finished, this, [=]() {
            // 回到主线程
            QJsonObject data = watcher->result();
            m_scene->fromJson(data);

            progress->close();
            delete progress;
            delete watcher;

            statusBar()->showMessage("项目加载完成", 3000);
        });
        watcher->setFuture(future);
    }
};
```

**优化 3: 局部更新**

```cpp
void WallItem::setEndPos(const QPointF &pos) {
    // 记录旧的边界
    QRectF oldBounds = boundingRect();

    m_end = pos;
    updateGeometry();

    // 只更新变化的区域
    QRectF newBounds = boundingRect();
    QRectF updateRect = oldBounds.united(newBounds);

    update(updateRect);  // 不是 update() 整个场景!
}
```

**优化 4: 延迟加载**

```cpp
class AssetManager {
public:
    // 预加载常用资源
    void preloadCommon() {
        QStringList commonAssets = {"sofa_01", "table_01", "bed_01"};
        for (const QString &id : commonAssets) {
            loadAssetAsync(id);
        }
    }

    // 异步加载资源
    void loadAssetAsync(const QString &id) {
        if (m_loadingAssets.contains(id)) return;

        m_loadingAssets.insert(id);

        QtConcurrent::run([this, id]() {
            Asset asset = loadAssetFromDisk(id);

            QMetaObject::invokeMethod(this, [this, id, asset]() {
                m_assets[id] = asset;
                m_loadingAssets.remove(id);
                emit assetLoaded(id);
            }, Qt::QueuedConnection);
        });
    }

private:
    QHash<QString, Asset> m_assets;
    QSet<QString> m_loadingAssets;
};
```

**优化 5: 进度反馈**

```cpp
void DesignScene::fromJson(const QJsonObject &root) {
    QJsonArray walls = root["walls"].toArray();

    // 显示进度
    QProgressDialog progress("加载墙体...", QString(), 0, walls.size());
    progress.setWindowModality(Qt::WindowModal);

    for (int i = 0; i < walls.size(); ++i) {
        WallItem *wall = WallItem::fromJson(walls[i].toObject());
        addWall(wall);

        // 更新进度
        progress.setValue(i);

        // 处理事件,保持 UI 响应
        if (i % 10 == 0) {
            QApplication::processEvents();
        }
    }
}
```

**优化 6: 使用 QGraphicsView 缓存**

```cpp
class View2DWidget : public QGraphicsView {
public:
    View2DWidget(QWidget *parent = nullptr) : QGraphicsView(parent) {
        // 启用缓存模式
        setCacheMode(QGraphicsView::CacheBackground);

        // 优化渲染
        setViewportUpdateMode(QGraphicsView::MinimalViewportUpdate);
        setOptimizationFlag(QGraphicsView::DontAdjustForAntialiasing, true);

        // 抗锯齿仅在非拖拽时启用
        setRenderHint(QPainter::Antialiasing, true);
    }

protected:
    void mouseMoveEvent(QMouseEvent *event) override {
        // 拖拽时禁用抗锯齿 (提升性能)
        if (event->buttons() & Qt::LeftButton) {
            setRenderHint(QPainter::Antialiasing, false);
        }

        QGraphicsView::mouseMoveEvent(event);
    }

    void mouseReleaseEvent(QMouseEvent *event) override {
        // 释放后恢复抗锯齿
        setRenderHint(QPainter::Antialiasing, true);
        QGraphicsView::mouseReleaseEvent(event);
    }
};
```

**性能指标**:
| 操作 | 目标延迟 | 用户感知 |
|------|----------|----------|
| 鼠标跟随 | < 16ms | 流畅 |
| 按钮点击 | < 100ms | 即时 |
| 文件加载 | < 1s (小文件) | 可接受 |
| 3D 重建 | < 200ms | 可感知但不卡 |
| 保存文件 | < 2s | 可等待 |

**关键原则**:
- **16ms 规则**: 保持 60fps (1000ms / 60 = 16.67ms)
- **100ms 规则**: 响应用户操作必须在 100ms 内给反馈
- **异步至上**: 耗时操作必须异步
- **局部更新**: 只重绘变化的区域
- **进度反馈**: 长时间操作显示进度条

---

## 总结

本文档列举了 QtPlanArchitect 项目开发中的 10 大技术难点:

1. **墙体几何计算** - 使用 Qt 几何类,避免手动三角函数
2. **墙体智能连接** - 容差判断 + 简化算法
3. **2D/3D 同步** - 坐标转换 + 延迟更新
4. **吸附系统** - 空间分区 + 优先级 + 自适应阈值
5. **门窗开洞** - 分段渲染 (推荐) 或 CSG (高级)
6. **OpenGL 性能** - 批量渲染 + VAO + 视锥剔除 + LOD
7. **撤销/重做** - 保存数据不保存指针 + 合并命令
8. **内存管理** - 明确所有权 + 智能指针 + OpenGL 资源释放
9. **版本兼容** - 版本号 + 默认值 + 迁移函数
10. **交互响应性** - 事件节流 + 异步加载 + 局部更新

**核心思想**:
- **简化优先**: 复杂算法先用简化版,够用就行
- **性能第二**: 先实现功能,再优化性能
- **测试驱动**: 每个难点都配对应测试用例
- **用户体验**: 所有优化的目标都是提升用户体验

遇到问题时,参考本文档找到对应章节,按照解决方案逐步实现。如果遇到新的难点,及时补充到本文档中。
