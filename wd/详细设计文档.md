# QtPlanArchitect 详细设计文档 (Detailed Design Document)

**版本**: V1.0 **目标平台**: Windows 10/11 **技术栈**: Qt 6.5+, C++17, OpenGL 3.3+ **文档类型**: 详细设计规格书 (DDD)

------

## 目录

1. [系统架构设计](https://claude.ai/chat/13d14ee6-502b-4f75-93e7-f589dcbd8ac8#1-系统架构设计)
2. [核心类详细设计](https://claude.ai/chat/13d14ee6-502b-4f75-93e7-f589dcbd8ac8#2-核心类详细设计)
3. [关键算法实现](https://claude.ai/chat/13d14ee6-502b-4f75-93e7-f589dcbd8ac8#3-关键算法实现)
4. [数据流与状态管理](https://claude.ai/chat/13d14ee6-502b-4f75-93e7-f589dcbd8ac8#4-数据流与状态管理)
5. [性能优化策略](https://claude.ai/chat/13d14ee6-502b-4f75-93e7-f589dcbd8ac8#5-性能优化策略)
6. [测试策略](https://claude.ai/chat/13d14ee6-502b-4f75-93e7-f589dcbd8ac8#6-测试策略)

------

## 1. 系统架构设计

### 1.1 分层架构

```
┌─────────────────────────────────────────────────────────┐
│              Presentation Layer (UI)                     │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
│  │ MainWindow   │  │ PropertiesPanel│ │ComponentLibrary│ │
│  │ (QMainWindow)│  │ (QDockWidget)  │ │ (QListWidget)  │ │
│  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘  │
└─────────┼──────────────────┼──────────────────┼─────────┘
          │                  │                  │
┌─────────┼──────────────────┼──────────────────┼─────────┐
│         │      Business Logic Layer            │         │
│  ┌──────▼───────┐  ┌──────▼───────┐  ┌───────▼──────┐  │
│  │DesignScene   │  │ToolManager   │  │ AssetManager │  │
│  │(QGraphicsScene)│ │(StateMachine)│  │(ResourcePool)│  │
│  └──────┬───────┘  └──────────────┘  └──────────────┘  │
│         │                                                │
│  ┌──────▼───────────────────────────────────────────┐  │
│  │          Graphics Items (Model Objects)           │  │
│  │  WallItem | OpeningItem | FurnitureItem          │  │
│  └───────────────────────────────────────────────────┘  │
└──────────────────────────┬───────────────────────────────┘
                           │
┌──────────────────────────┼───────────────────────────────┐
│         Rendering Layer   │                               │
│  ┌──────────────┐  ┌─────▼──────┐  ┌─────────────────┐  │
│  │View2DWidget  │  │View3DWidget │  │ RenderEngine    │  │
│  │(QGraphicsView)│ │(QOpenGLWidget)│ │(Mesh Generator) │  │
│  └──────────────┘  └────────────┘  └─────────────────┘  │
└─────────────────────────────────────────────────────────┘
                           │
┌──────────────────────────┼───────────────────────────────┐
│         Data Layer        │                               │
│  ┌──────────────┐  ┌─────▼──────┐  ┌─────────────────┐  │
│  │ProjectManager│  │JSONSerializer│ │ UndoStack       │  │
│  │(Singleton)   │  │(I/O Handler) │ │ (QUndoStack)    │  │
│  └──────────────┘  └────────────┘  └─────────────────┘  │
└─────────────────────────────────────────────────────────┘
```

### 1.2 设计模式应用

| 模式          | 应用场景      | 实现类                                        |
| ------------- | ------------- | --------------------------------------------- |
| **Singleton** | 全局资源管理  | `AssetManager`, `ProjectManager`              |
| **Command**   | 撤销/重做系统 | `AddWallCommand`, `MoveItemCommand`           |
| **State**     | 工具切换      | `ToolManager` (Select/DrawWall/DrawFurniture) |
| **Observer**  | 2D/3D同步     | Scene → View3DWidget (通过信号槽)             |
| **Factory**   | 图元创建      | `ItemFactory::create(ItemType)`               |
| **Strategy**  | 吸附算法      | `SnapStrategy` 接口 + 多种实现                |

------

## 2. 核心类详细设计

### 2.1 场景管理 (DesignScene)

```cpp
class DesignScene : public QGraphicsScene {
    Q_OBJECT
    
public:
    enum Mode {
        Mode_Select,
        Mode_DrawWall,
        Mode_PlaceFurniture,
        Mode_Measure
    };
    
    explicit DesignScene(QObject *parent = nullptr);
    
    // === 模式控制 ===
    void setMode(Mode mode);
    Mode currentMode() const { return m_currentMode; }
    
    // === 网格与吸附 ===
    void setGridVisible(bool visible);
    void setSnapEnabled(bool enabled);
    QPointF snapPoint(const QPointF &pos) const;
    
    // === 图层管理 ===
    void setBackgroundImage(const QPixmap &pixmap);
    void setBackgroundOpacity(qreal opacity);
    void calibrateScale(qreal pixelsPerMm);
    
    // === 对象管理 ===
    QList<WallItem*> walls() const;
    QList<FurnitureItem*> furniture() const;
    void addWall(WallItem *wall);
    void addFurniture(FurnitureItem *item);
    
    // === 序列化 ===
    QJsonObject toJson() const;
    void fromJson(const QJsonObject &json);
    
signals:
    void sceneContentChanged();
    void modeChanged(Mode mode);
    void itemSelected(QGraphicsItem *item);
    
protected:
    // === 交互事件 ===
    void mousePressEvent(QGraphicsSceneMouseEvent *event) override;
    void mouseMoveEvent(QGraphicsSceneMouseEvent *event) override;
    void mouseReleaseEvent(QGraphicsSceneMouseEvent *event) override;
    void keyPressEvent(QKeyEvent *event) override;
    
    void drawBackground(QPainter *painter, const QRectF &rect) override;
    
private:
    // === 内部状态 ===
    Mode m_currentMode;
    QPixmap m_backgroundImage;
    qreal m_backgroundOpacity;
    qreal m_pixelsPerMm;
    bool m_gridVisible;
    bool m_snapEnabled;
    
    // === 绘制中的临时数据 ===
    QPointF m_drawStartPoint;
    WallItem *m_tempWall;
    
    // === 辅助功能 ===
    void drawGrid(QPainter *painter, const QRectF &rect);
    SnapPoint findNearestSnapPoint(const QPointF &pos) const;
    void handleWallDrawing(QGraphicsSceneMouseEvent *event);
    void finalizeWall();
};
```

**关键实现细节**:

#### 网格绘制算法

```cpp
void DesignScene::drawGrid(QPainter *painter, const QRectF &rect) {
    const qreal smallGrid = 100.0;  // 100mm
    const qreal largeGrid = 1000.0; // 1000mm (1米)
    
    painter->setPen(QPen(QColor(200, 200, 200), 0.5));
    
    // 绘制小网格
    for (qreal x = floor(rect.left()/smallGrid)*smallGrid; 
         x < rect.right(); x += smallGrid) {
        painter->drawLine(QPointF(x, rect.top()), 
                         QPointF(x, rect.bottom()));
    }
    for (qreal y = floor(rect.top()/smallGrid)*smallGrid; 
         y < rect.bottom(); y += smallGrid) {
        painter->drawLine(QPointF(rect.left(), y), 
                         QPointF(rect.right(), y));
    }
    
    // 绘制大网格（加粗）
    painter->setPen(QPen(QColor(150, 150, 150), 1.0));
    for (qreal x = floor(rect.left()/largeGrid)*largeGrid; 
         x < rect.right(); x += largeGrid) {
        painter->drawLine(QPointF(x, rect.top()), 
                         QPointF(x, rect.bottom()));
    }
    for (qreal y = floor(rect.top()/largeGrid)*largeGrid; 
         y < rect.bottom(); y += largeGrid) {
        painter->drawLine(QPointF(rect.left(), y), 
                         QPointF(rect.right(), y));
    }
}
```

------

### 2.2 墙体类 (WallItem)

```cpp
class WallItem : public QGraphicsPolygonItem {
public:
    struct WallEndpoint {
        QPointF position;
        QVector<WallItem*> connectedWalls;
        bool isSnapped;
    };
    
    explicit WallItem(const QPointF &start, const QPointF &end);
    
    // === 几何属性 ===
    QPointF startPos() const { return m_start; }
    QPointF endPos() const { return m_end; }
    void setStartPos(const QPointF &pos);
    void setEndPos(const QPointF &pos);
    
    qreal thickness() const { return m_thickness; }
    void setThickness(qreal t);
    
    qreal height() const { return m_height; }
    void setHeight(qreal h);
    
    // === 核心算法 ===
    void updateGeometry();  // 重新计算 Polygon 的4个顶点
    QVector<QVector3D> get3DVertices() const;  // 生成3D立方体顶点
    
    // === 连接管理 ===
    void connectToWall(WallItem *other, bool atStart);
    void disconnectFromWall(WallItem *other);
    QList<WallItem*> connectedWalls() const;
    
    // === 开洞信息 ===
    void addOpening(OpeningItem *opening);
    void removeOpening(OpeningItem *opening);
    QList<OpeningItem*> openings() const { return m_openings; }
    
    // === 交互 ===
    enum { Type = UserType + 1 };
    int type() const override { return Type; }
    
    QPainterPath shape() const override;  // 精确碰撞检测
    void paint(QPainter *painter, const QStyleOptionGraphicsItem *option,
               QWidget *widget) override;
    
    // === 序列化 ===
    QJsonObject toJson() const;
    static WallItem* fromJson(const QJsonObject &json);
    
private:
    QPointF m_start, m_end;
    qreal m_thickness;
    qreal m_height;
    
    WallEndpoint m_startEndpoint;
    WallEndpoint m_endEndpoint;
    
    QList<OpeningItem*> m_openings;
    
    // 辅助计算
    QPolygonF calculatePolygon() const;
    QVector<QPointF> calculateCornerPoints() const;
};
```

**关键实现**:

#### 墙体Polygon计算

```cpp
void WallItem::updateGeometry() {
    QLineF centerLine(m_start, m_end);
    QLineF perpendicular = centerLine.normalVector();
    perpendicular.setLength(m_thickness / 2.0);
    
    // 计算4个角点
    QPointF p1 = m_start + QPointF(perpendicular.dx(), perpendicular.dy());
    QPointF p2 = m_start - QPointF(perpendicular.dx(), perpendicular.dy());
    QPointF p3 = m_end - QPointF(perpendicular.dx(), perpendicular.dy());
    QPointF p4 = m_end + QPointF(perpendicular.dx(), perpendicular.dy());
    
    QPolygonF polygon;
    polygon << p1 << p2 << p3 << p4;
    setPolygon(polygon);
}
```

#### 3D顶点生成（用于OpenGL渲染）

```cpp
QVector<QVector3D> WallItem::get3DVertices() const {
    QVector<QVector3D> vertices;
    QPolygonF base = polygon();
    
    // 底部4个顶点 (Y=0)
    for (const QPointF &p : base) {
        vertices << QVector3D(p.x(), 0, p.y());
    }
    
    // 顶部4个顶点 (Y=height)
    for (const QPointF &p : base) {
        vertices << QVector3D(p.x(), m_height, p.y());
    }
    
    return vertices;
}
```

------

### 2.3 家具类 (FurnitureItem)

```cpp
class FurnitureItem : public QGraphicsSvgItem {
    Q_OBJECT
    
public:
    explicit FurnitureItem(const QString &assetId);
    
    // === 资产管理 ===
    QString assetId() const { return m_assetId; }
    QString modelPath() const;  // 返回 .obj/.glb 路径
    QString iconPath() const;   // 返回 .svg 路径
    
    // === 3D属性 ===
    qreal elevation() const { return m_elevation; }
    void setElevation(qreal z);  // 离地高度
    
    QVector3D scale3D() const { return m_scale3D; }
    void setScale3D(const QVector3D &scale);
    
    qreal rotation() const { return m_rotation; }
    void setRotation(qreal angle);  // 0-360度
    
    // === 交互 ===
    enum { Type = UserType + 3 };
    int type() const override { return Type; }
    
    void paint(QPainter *painter, const QStyleOptionGraphicsItem *option,
               QWidget *widget) override;
    
    // === 变换矩阵（用于3D渲染）===
    QMatrix4x4 transformMatrix() const;
    
    // === 序列化 ===
    QJsonObject toJson() const;
    static FurnitureItem* fromJson(const QJsonObject &json);
    
private:
    QString m_assetId;
    qreal m_elevation;
    QVector3D m_scale3D;
    qreal m_rotation;
};
```

------

### 2.4 3D渲染器 (View3DWidget)

```cpp
class View3DWidget : public QOpenGLWidget, protected QOpenGLFunctions_3_3_Core {
    Q_OBJECT
    
public:
    explicit View3DWidget(QWidget *parent = nullptr);
    ~View3DWidget();
    
    // === 场景绑定 ===
    void setScene(DesignScene *scene);
    
    // === 相机控制 ===
    void resetCamera();
    void setCameraPosition(const QVector3D &pos);
    void setCameraTarget(const QVector3D &target);
    
public slots:
    void onSceneChanged();  // 响应 Scene 的 sceneContentChanged 信号
    
protected:
    // === OpenGL 生命周期 ===
    void initializeGL() override;
    void resizeGL(int w, int h) override;
    void paintGL() override;
    
    // === 交互 ===
    void mousePressEvent(QMouseEvent *event) override;
    void mouseMoveEvent(QMouseEvent *event) override;
    void wheelEvent(QWheelEvent *event) override;
    
private:
    DesignScene *m_scene;
    
    // === 相机参数 ===
    QVector3D m_cameraPos;
    QVector3D m_cameraTarget;
    QVector3D m_cameraUp;
    QMatrix4x4 m_projectionMatrix;
    QMatrix4x4 m_viewMatrix;
    
    // === 交互状态 ===
    QPoint m_lastMousePos;
    qreal m_yaw, m_pitch;
    qreal m_distance;
    
    // === OpenGL资源 ===
    QOpenGLShaderProgram *m_shaderProgram;
    QOpenGLVertexArrayObject m_vao;
    QOpenGLBuffer m_vbo;
    
    struct MeshData {
        QVector<GLfloat> vertices;
        QVector<GLuint> indices;
    };
    QHash<QString, MeshData> m_modelCache;  // 模型缓存
    
    // === 渲染流程 ===
    void renderWalls();
    void renderFurniture();
    void renderOpenings();
    
    void updateCameraVectors();
    MeshData loadModel(const QString &filePath);
    void generateWallMesh(WallItem *wall, MeshData &mesh);
};
```

**核心渲染逻辑**:

```cpp
void View3DWidget::paintGL() {
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glEnable(GL_DEPTH_TEST);
    
    m_shaderProgram->bind();
    m_shaderProgram->setUniformValue("projection", m_projectionMatrix);
    m_shaderProgram->setUniformValue("view", m_viewMatrix);
    
    // 1. 渲染所有墙体
    for (WallItem *wall : m_scene->walls()) {
        MeshData mesh;
        generateWallMesh(wall, mesh);
        
        // 上传到GPU
        m_vbo.bind();
        m_vbo.allocate(mesh.vertices.constData(), 
                       mesh.vertices.size() * sizeof(GLfloat));
        
        QMatrix4x4 model;
        m_shaderProgram->setUniformValue("model", model);
        m_shaderProgram->setUniformValue("color", QVector3D(0.9, 0.9, 0.9));
        
        glDrawArrays(GL_TRIANGLES, 0, mesh.vertices.size() / 3);
    }
    
    // 2. 渲染家具
    for (FurnitureItem *item : m_scene->furniture()) {
        QString modelPath = item->modelPath();
        if (!m_modelCache.contains(modelPath)) {
            m_modelCache[modelPath] = loadModel(modelPath);
        }
        
        MeshData &mesh = m_modelCache[modelPath];
        m_vbo.bind();
        m_vbo.allocate(mesh.vertices.constData(), 
                       mesh.vertices.size() * sizeof(GLfloat));
        
        m_shaderProgram->setUniformValue("model", item->transformMatrix());
        m_shaderProgram->setUniformValue("color", QVector3D(0.7, 0.5, 0.3));
        
        glDrawElements(GL_TRIANGLES, mesh.indices.size(), 
                      GL_UNSIGNED_INT, mesh.indices.constData());
    }
    
    m_shaderProgram->release();
}
```

------

## 3. 关键算法实现

### 3.1 墙体智能连接算法

#### 问题描述

当新墙体端点靠近已有墙体时，需要:

1. 判断连接类型 (L型 / T型)
2. 计算融合后的顶点坐标
3. 更新两者的 Polygon

#### 算法实现

```cpp
class WallJoinAlgorithm {
public:
    enum JoinType {
        None,
        LCorner,    // L型连接（端点对端点）
        TJunction   // T型连接（端点对墙体中间）
    };
    
    struct JoinResult {
        JoinType type;
        QPointF joinPoint;
        QVector<QPointF> newVertices1;  // 墙体1的新顶点
        QVector<QPointF> newVertices2;  // 墙体2的新顶点
    };
    
    static JoinResult computeJoin(WallItem *wall1, bool useStart1,
                                   WallItem *wall2, bool useStart2) {
        JoinResult result;
        result.type = None;
        
        QPointF p1 = useStart1 ? wall1->startPos() : wall1->endPos();
        QPointF p2 = useStart2 ? wall2->startPos() : wall2->endPos();
        
        // 1. 判断是否足够接近（吸附距离）
        if (QLineF(p1, p2).length() > SNAP_DISTANCE) {
            return result;
        }
        
        // 2. 计算两墙体的方向向量
        QLineF line1(wall1->startPos(), wall1->endPos());
        QLineF line2(wall2->startPos(), wall2->endPos());
        
        qreal angle = angleBetween(line1.angle(), line2.angle());
        
        // 3. 判断连接类型
        if (qAbs(angle - 90) < 5) {  // 近似90度
            result.type = LCorner;
            result.joinPoint = (p1 + p2) / 2.0;  // 取中点
            
            // 计算L型连接的角点
            result.newVertices1 = calculateLCornerVertices(
                wall1, wall2, result.joinPoint, useStart1);
            result.newVertices2 = calculateLCornerVertices(
                wall2, wall1, result.joinPoint, useStart2);
        }
        
        return result;
    }
    
private:
    static constexpr qreal SNAP_DISTANCE = 20.0;  // 像素
    
    static qreal angleBetween(qreal a1, qreal a2) {
        qreal diff = qAbs(a1 - a2);
        return qMin(diff, 360 - diff);
    }
    
    static QVector<QPointF> calculateLCornerVertices(
        WallItem *wall, WallItem *otherWall, 
        const QPointF &corner, bool atStart) {
        
        QVector<QPointF> vertices;
        
        // 获取墙体的4个原始顶点
        QPolygonF poly = wall->polygon();
        
        // 计算墙体方向的垂直向量
        QLineF centerLine(wall->startPos(), wall->endPos());
        QLineF normal = centerLine.normalVector();
        normal.setLength(wall->thickness() / 2.0);
        
        // ... 复杂的几何计算逻辑 ...
        // 核心思路：找到内角点和外角点，替换原顶点
        
        return vertices;
    }
};
```

------

### 3.2 门窗布尔运算（墙体挖洞）

#### 2D实现（简化版）

```cpp
void OpeningItem::paint(QPainter *painter, 
                        const QStyleOptionGraphicsItem *option,
                        QWidget *widget) {
    Q_UNUSED(option);
    Q_UNUSED(widget);
    
    // 1. 绘制白色背景（遮挡墙体线条）
    painter->setBrush(Qt::white);
    painter->setPen(Qt::NoPen);
    painter->drawRect(boundingRect());
    
    // 2. 绘制门窗符号
    painter->setPen(QPen(Qt::black, 2));
    if (m_type == Door) {
        // 绘制门的弧线和门框
        QPainterPath path;
        path.moveTo(0, 0);
        path.arcTo(0, 0, m_width, m_width, 0, 90);
        painter->drawPath(path);
    } else if (m_type == Window) {
        // 绘制窗户的双线
        painter->drawLine(0, 0, m_width, 0);
        painter->drawLine(0, 5, m_width, 5);
    }
}
```

#### 3D实现（CSG算法）

```cpp
MeshData View3DWidget::generateWallWithOpenings(WallItem *wall) {
    MeshData baseMesh = generateCuboidMesh(
        wall->startPos(), wall->endPos(), 
        wall->thickness(), wall->height());
    
    // 对每个开洞执行布尔减法
    for (OpeningItem *opening : wall->openings()) {
        QRectF openingRect = opening->boundingRect();
        
        // 计算开洞在墙体上的3D位置
        qreal distanceAlongWall = opening->distanceFromStart();
        QVector3D openingCenter = wall->pointAtDistance(distanceAlongWall);
        
        // 生成开洞的立方体Mesh
        MeshData holeMesh = generateCuboidMesh(
            openingCenter, 
            opening->width(), opening->height(), 
            wall->thickness() + 10);  // 稍微穿透
        
        // 执行CSG减法（这里需要引入第三方库如 libigl 或 CGAL）
        baseMesh = CSG::subtract(baseMesh, holeMesh);
    }
    
    return baseMesh;
}
```

**注**: 完整的CSG实现较复杂，建议使用现成库。简化版可以用"分段绘制"实现：

```cpp
// 简化版：将墙体分成3段（开洞前、开洞、开洞后）
void renderWallSegmented(WallItem *wall) {
    qreal totalLength = QLineF(wall->startPos(), wall->endPos()).length();
    
    for (OpeningItem *opening : wall->openings()) {
        qreal start = opening->distanceFromStart();
        qreal end = start + opening->width();
        
        // 渲染 [0, start] 段
        renderWallSegment(wall, 0, start);
        
        // 跳过 [start, end] 段（开洞）
        
        // 渲染 [end, totalLength] 段
        renderWallSegment(wall, end, totalLength);
    }
}
```

------

### 3.3 吸附系统 (Snap System)

```cpp
class SnapEngine {
public:
    struct SnapPoint {
        QPointF position;
        enum Type { Endpoint, Midpoint, Perpendicular, Grid } type;
        qreal priority;  // 优先级（越小越优先）
    };
    
    static SnapPoint findBestSnap(const QPointF &cursor, 
                                   const DesignScene *scene,
                                   qreal tolerance = 10.0) {
        QVector<SnapPoint> candidates;
        
        // 1. 收集所有墙体的端点和中点
        for (WallItem *wall : scene->walls()) {
            candidates << SnapPoint{wall->startPos(), Endpoint, 1.0};
            candidates << SnapPoint{wall->endPos(), Endpoint, 1.0};
            
            QPointF mid = (wall->startPos() + wall->endPos()) / 2.0;
            candidates << SnapPoint{mid, Midpoint, 2.0};
        }
        
        // 2. 收集网格点
        if (scene->isSnapToGridEnabled()) {
            qreal gridSize = 100.0;  // 100mm
            QPointF gridPoint(
                qRound(cursor.x() / gridSize) * gridSize,
                qRound(cursor.y() / gridSize) * gridSize
            );
            candidates << SnapPoint{gridPoint, Grid, 3.0};
        }
        
        // 3. 按距离和优先级排序
        std::sort(candidates.begin(), candidates.end(), 
                  [&cursor](const SnapPoint &a, const SnapPoint &b) {
            qreal distA = QLineF(cursor, a.position).length();
            qreal distB = QLineF(cursor, b.position).length();
            
            if (qAbs(distA - distB) < 1e-3) {
                return a.priority < b.priority;
            }
            return distA < distB;
        });
        
        // 4. 返回最近且在容差范围内的点
        if (!candidates.isEmpty()) {
            SnapPoint best = candidates.first();
            if (QLineF(cursor, best.position).length() <= tolerance) {
                return best;
            }
        }
        
        return SnapPoint{cursor, Grid, 999};  // 无吸附
    }
};
```

------

## 4. 数据流与状态管理

### 4.1 撤销/重做系统

```cpp
// 基础命令类
class Command : public QUndoCommand {
public:
    explicit Command(DesignScene *scene, QUndoCommand *parent = nullptr)
        : QUndoCommand(parent), m_scene(scene) {}
    
protected:
    DesignScene *m_scene;
};

// 添加墙体命令
class AddWallCommand : public Command {
public:
    AddWallCommand(DesignScene *scene, WallItem *wall)
        : Command(scene), m_wall(wall) {}
    
    void undo() override {
        m_scene->removeItem(m_wall);
        m_scene->update();
    }
    
    void redo() override {
        m_scene->addItem(m_wall);
        m_scene->addWall(m_wall);
        m_scene->update();
    }
    
private:
    WallItem *m_wall;
};

// 移动图元命令
class MoveItemCommand : public Command {
public:
    MoveItemCommand(DesignScene *scene, QGraphicsItem *item,
                    const QPointF &oldPos, const QPointF &newPos)
        : Command(scene), m_item(item), 
          m_oldPos(oldPos), m_newPos(newPos) {}
    void undo() override {
    m_item->setPos(m_oldPos);
    m_scene->update();
}

void redo() override {
    m_item->setPos(m_newPos);
    m_scene->update();
}
```

private: QGraphicsItem *m_item; QPointF m_oldPos, m_newPos; };

```
**使用方式**:
```cpp
// 在 MainWindow 中
QUndoStack *undoStack = new QUndoStack(this);

// 执行命令
WallItem *wall = new WallItem(start, end);
undoStack->push(new AddWallCommand(scene, wall));

// 绑定到UI
QAction *undoAction = undoStack->createUndoAction(this, tr("撤销"));
undoAction->setShortcut(QKeySequence::Undo);
toolbar->addAction(undoAction);
```

------

### 4.2 资源管理器 (AssetManager)

```cpp
class AssetManager {
public:
    static AssetManager* instance() {
        static AssetManager instance;
        return &instance;
    }
    
    struct Asset {
        QString id;
        QString name;
        QString category;  // "living_room", "bedroom", etc.
        QString svgPath;   // 2D图标
        QString modelPath; // 3D模型
        QSizeF defaultSize;
    };
    
    // 加载资源库
    void loadAssets(const QString &catalogPath) {
        QFile file(catalogPath);
        if (!file.open(QIODevice::ReadOnly)) return;
        
        QJsonDocument doc = QJsonDocument::fromJson(file.readAll());
        QJsonArray assets = doc.array();
        
        for (const QJsonValue &val : assets) {
            QJsonObject obj = val.toObject();
            Asset asset;
            asset.id = obj["id"].toString();
            asset.name = obj["name"].toString();
            asset.category = obj["category"].toString();
            asset.svgPath = obj["svg"].toString();
            asset.modelPath = obj["model"].toString();
            // ...
            
            m_assets[asset.id] = asset;
        }
    }
    
    Asset getAsset(const QString &id) const {
        return m_assets.value(id);
    }
    
    QList<Asset> getAssetsByCategory(const QString &category) const {
        QList<Asset> result;
        for (const Asset &asset : m_assets) {
            if (asset.category == category) {
                result << asset;
            }
        }
        return result;
    }
    
private:
    AssetManager() {}
    QHash<QString, Asset> m_assets;
};
```

**资源目录结构**:

```
assets/
├── catalog.json           # 资源索引文件
├── icons/
│   ├── sofa_01.svg
│   ├── table_01.svg
│   └── ...
└── models/
    ├── sofa_01.obj
    ├── table_01.glb
    └── ...
```

------

## 5. 性能优化策略

### 5.1 渲染优化

#### 场景剔除 (Frustum Culling)

```cpp
void View3DWidget::paintGL() {
    // 计算视锥体
    QRect viewport = rect();
    QMatrix4x4 vp = m_projectionMatrix * m_viewMatrix;
    
    // 只渲染可见对象
    for (WallItem *wall : m_scene->walls()) {
        QRectF bounds = wall->boundingRect();
        if (isInFrustum(bounds, vp)) {
            renderWall(wall);
        }
    }
}
```

#### 批量渲染

```cpp
// 将所有墙体合并成一个大 Mesh，减少 Draw Call
void View3DWidget::renderWallsBatched() {
    QVector<GLfloat> allVertices;
    
    for (WallItem *wall : m_scene->walls()) {
        QVector<QVector3D> verts = wall->get3DVertices();
        for (const QVector3D &v : verts) {
            allVertices << v.x() << v.y() << v.z();
        }
    }
    
    m_vbo.bind();
    m_vbo.allocate(allVertices.constData(), 
                   allVertices.size() * sizeof(GLfloat));
    
    glDrawArrays(GL_TRIANGLES, 0, allVertices.size() / 3);
}
```

### 5.2 内存优化

#### 模型共享

```cpp
// 多个 FurnitureItem 共享同一个 3D 模型数据
class ModelCache {
public:
    static ModelCache* instance();
    
    QSharedPointer<MeshData> getModel(const QString &path) {
        if (!m_cache.contains(path)) {
            m_cache[path] = QSharedPointer<MeshData>::create(loadModel(path));
        }
        return m_cache[path];
    }
    
private:
    QHash<QString, QSharedPointer<MeshData>> m_cache;
};
```

------

## 6. 测试策略

### 6.1 单元测试

```cpp
// 测试墙体几何计算
class TestWallItem : public QObject {
    Q_OBJECT
    
private slots:
    void testPolygonCalculation() {
        WallItem wall(QPointF(0, 0), QPointF(5000, 0));
        wall.setThickness(240);
        
        QPolygonF poly = wall.polygon();
        QCOMPARE(poly.size(), 4);
        
        // 验证宽度
        qreal width = QLineF(poly[0], poly[1]).length();
        QVERIFY(qAbs(width - 240) < 1e-3);
    }
    
    void testWallJoin() {
        WallItem wall1(QPointF(0, 0), QPointF(5000, 0));
        WallItem wall2(QPointF(5000, 0), QPointF(5000, 4000));
        
        auto result = WallJoinAlgorithm::computeJoin(
            &wall1, false, &wall2, true);
        
        QCOMPARE(result.type, WallJoinAlgorithm::LCorner);
        QVERIFY(result.joinPoint == QPointF(5000, 0));
    }
};
```

### 6.2 集成测试

```cpp
// 测试完整工作流
void TestWorkflow::testBasicFlow() {
    // 1. 创建场景
    DesignScene scene;
    
    // 2. 导入底图
    QPixmap bg("test_blueprint.png");
    scene.setBackgroundImage(bg);
    scene.calibrateScale(0.05);  // 1px = 0.05mm
    
    // 3. 绘制墙体
    WallItem *wall1 = new WallItem(QPointF(0, 0), QPointF(5000, 0));
    scene.addWall(wall1);
    
    // 4. 添加家具
    FurnitureItem *sofa = new FurnitureItem("sofa_01");
    sofa->setPos(2500, 2000);
    scene.addItem(sofa);
    
    // 5. 验证序列化
    QJsonObject json = scene.toJson();
    QVERIFY(json.contains("walls"));
    QVERIFY(json.contains("furniture"));
    
    // 6. 测试反序列化
    DesignScene scene2;
    scene2.fromJson(json);
    QCOMPARE(scene2.walls().size(), 1);
    QCOMPARE(scene2.furniture().size(), 1);
}
```

------

## 附录A: 依赖库清单

| 库名      | 版本   | 用途                  | 许可证          |
| --------- | ------ | --------------------- | --------------- |
| Qt        | 6.5+   | UI框架                | LGPL/Commercial |
| OpenGL    | 3.3+   | 3D渲染                | -               |
| Assimp    | 5.0+   | 模型加载 (.obj, .glb) | BSD             |
| GLM       | 0.9.9+ | 数学库                | MIT             |
| RapidJSON | 1.1+   | JSON解析              | MIT             |

------

## 附录B: 编译配置

**CMakeLists.txt**:

```cmake
cmake_minimum_required(VERSION 3.16)
project(QtPlanArchitect VERSION 1.0 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

find_package(Qt6 REQUIRED COMPONENTS Core Widgets OpenGL OpenGLWidgets Svg)
find_package(assimp REQUIRED)

add_executable(QtPlanArchitect
    src/main.cpp
    src/mainwindow.cpp
    src/designscene.cpp
    src/wallitem.cpp
    src/furnitureitem.cpp
    src/view3dwidget.cpp
    # ...
)

target_link_libraries(QtPlanArchitect
    Qt6::Core
    Qt6::Widgets
    Qt6::OpenGL
    Qt6::OpenGLWidgets
    Qt6::Svg
    assimp::assimp
)
```

